//
// Created by cgkik on 4/13/2021.
//

// Server File
// Members: Calista Gasper, Liam Barry, Carly Etlinger
// Language: C

#include <unistd.h>         // write
#include <stdio.h>
#include <sys/socket.h>
#include <stdlib.h>
#include <netinet/in.h>
#include <arpa/inet.h>      // inet_addr
#include <string.h>         // strlen
#define PORT 8080
int main(int argc, char const *argv[])
{
    int serverSocket, clientSocket, c, readSize;
    struct sockaddr_in server, client;
    //int opt = 1;
    //int addrlen = sizeof(address);
    char buffer[1024];
    //char *hello = "Hello from server";
    char messageToClient[2000];
    char clientResponse[2000];

    // Creating socket
    serverSocket = socket(AF_INET, SOCK_STREAM, 0);
    // error handling creation of socket
    if (serverSocket == -1)
    {
        printf("Couldn't create socket");
    }
    puts("Socket successfully created");

    // Creating the sockaddr_in structure with values
    server.sin_family = AF_INET;
    server.sin_addr.s_addr = INADDR_ANY;
    server.sin_port = htons(8888);

    // bind is binding the socket to the address and port number specified in addr(custom data structure)
    // we binded the server to local host (using INADDR_ANY to specify the ip address)
    if (bind(serverSocket, (struct sockaddr *)&server,
             sizeof(server))<0)
    {
        // print error message
        perror("bind failed");
        return 1;
    }
    puts("Bind successfully completed");

    // listen puts the server in passive listen mode, where it waits for the client to approach the
    // server to make a connection
    // backlog defines max length to which the queue of pending connections for serverSocket may grow
    // 3 indicates backlog
    listen(serverSocket, 3);

    // time to start accepting connections
    puts("Waiting for connections...");
    c = sizeof(struct sockaddr_in);

    // accept connection from new client
    clientSocket = accept(serverSocket, (struct sockaddr *)&client, (socklen_t*)&c);
    // error handle new connection
    if (clientSocket < 0)
    {
        // output there was an error
        perror("Client accept failed");
        return 1;
    }
    puts("Client accept connection succeeded");

    // now send commands to client
    while(1)
    {
        printf("Enter command for client: ");
        scanf("%s", messageToClient);

        // send the client the command from the server
        if (send(clientSocket, messageToClient, strlen(messageToClient), 0) < 0)
        {
            // output error in sending the client data
            puts("Sending client data failed");
            return 1;
        }

        // receive the response from the client
        if (recv(clientSocket, clientResponse, 2000, 0) < 0)
        {
            // output error in receiving client data
            puts("Receiving client data failed");
            return 1;
        }
        // otherwise, if all is hunnky-dory, output the content from the client
        puts("Client response: ");
        puts(clientResponse);
        break;
    }

// this code allows the SERVER to receive from CLIENT. We want the other way around.
/*
    // receive messages from the client
    while ((readSize = recv(clientSocket, buffer, 1024, 0)) > 0)
    {
        // output content on server side
        printf("%s\n", buffer);
        // send message back to client ----- MAY NEED WHEN CLIENT SENDS COMMAND INFO BACK
        write(clientSocket, buffer, strlen(buffer));
    }
    // error handle client disconnection
    if(readSize == 0)
    {
        puts("Client disconnected");
        fflush(stdout);
    }
    // error handle an error
    else if (readSize == -1)
    {
        perror("Receiving content from client failed");
    }
*/
    close(clientSocket);
    return 0;
}