//
// Last updated 4/16/21 at 1:50pm
//

// Server File
// Members: Calista Gasper, Liam Barry, Carly Etlinger
// Language: C

#include <unistd.h>         // write
#include <stdio.h>
#include <sys/socket.h>
#include <stdlib.h>
#include <netinet/in.h>
#include <arpa/inet.h>      // inet_addr
#include <string.h>         // strlen
#define PORT 1240
#define received = -1;	    // wait for more commands
// define char command2[50] = "ipconfig | findstr /i \"ipv4"";


int main(int argc, char const *argv[])
{
    int serverSocket, clientSocket, c, readSize;
    struct sockaddr_in server, client;
    //int opt = 1;
    //int addrlen = sizeof(address);
    char messageToClient[2000];
    char buffer[1024];
    //char *hello = "Hello from server";
    char clientResponse[2000];
    // Creating socket
    serverSocket = socket(AF_INET, SOCK_STREAM, 0);
    // error handling creation of socket
    if (serverSocket == -1)
    {
        printf("Couldn't create socket");
    }
    puts("Socket successfully created");

    // Creating the sockaddr_in structure with values
    server.sin_family = AF_INET;
    server.sin_addr.s_addr = INADDR_ANY;
    server.sin_port = htons(PORT);

    // bind is binding the socket to the address and port number specified in addr(custom data structure)
    // we binded the server to local host (using INADDR_ANY to specify the ip address)
    if (bind(serverSocket, (struct sockaddr *)&server,
             sizeof(server))<0)
    {
        // print error message
        perror("bind failed");
        return 1;
    }
    puts("Bind successfully completed");

    // listen puts the server in passive listen mode, where it waits for the client to approach the
    // server to make a connection
    // backlog defines max length to which the queue of pending connections for serverSocket may grow
    // 3 indicates backlog
    listen(serverSocket, 3);

    // time to start accepting connections
    puts("Waiting for connections...");
    c = sizeof(struct sockaddr_in);

    // accept connection from new client
    clientSocket = accept(serverSocket, (struct sockaddr *)&client, (socklen_t*)&c);
    // error handle new connection
    if (clientSocket < 0)
    {
        // output there was an error
        perror("Client accept failed");
        return 1;
    }
    puts("Client accept connection succeeded");

    // now send command to client

    char command1[50] = "whoami";
    char command2[10] = "TASKLIST";
    char command3[50] = "ipconfig /all | findstr /i \"ipv4\"";
    char command4[50] = "ipconfig /all | findstr /i \"physical\"";
    char command5[50] = "systeminfo | findstr /B /C:\"OS Name\"";
    // add command for graceful teardown when server is done
    char command6[50] = "exit";

    while(1){

        printf("Enter command for client: ");
        scanf("%s", messageToClient);

        if (strcmp(messageToClient, command1) == 0){
            // sending command to client
            // take the command entered here, on the server, and send to the client so the
            // client can gather appropriate information
            write(clientSocket, messageToClient, strlen(messageToClient));
            // prepare server for outputting the received info
            printf("here are your results for 'whoami'....");
            printf("\n");
            // receive the data from the server, and print it
            //recv(clientSocket, clientResponse, strlen(clientResponse), 2000);
            recv(clientSocket, clientResponse, 2000, 0);

            //fflush(stdout);
            puts(clientResponse);
            //printf("Test!\n");

            // clean out the buffer for the next command
            messageToClient[2000] = '\0';

            continue;
        }

        if (strcmp(messageToClient, command2) == 0){
            write(clientSocket, messageToClient, strlen(messageToClient));
            printf("here are your results for 'tasklist'....");
            printf("\n");
            printf(recv(clientSocket, clientResponse, strlen(clientResponse), 2000));
            //system(command2);
            continue;
        }

        if(strcmp(messageToClient, command3) == 0){
            write(clientSocket, messageToClient, strlen(messageToClient));
            printf("here are your results for 'ipv4'....");
            printf("\n");
            printf(recv(clientSocket, clientResponse, strlen(clientResponse), 2000));
           // system(command3);
            continue;
        }

        if(strcmp(messageToClient, command4) == 0){
            write(clientSocket, messageToClient, strlen(messageToClient));
            printf("here are your results for 'MAC addr'....");
            printf("\n");
            printf(recv(clientSocket, clientResponse, strlen(clientResponse), 2000));
            //system(command4);
            continue;
        }

        if(strcmp(messageToClient, command5) == 0){
            write(clientSocket, messageToClient, strlen(messageToClient));
            printf("here are your results for 'OS Name'...");
            printf("\n");
            printf(recv(clientSocket, clientResponse, strlen(clientResponse), 2000));
            //system(command5);
            continue;
        }

        if(send(clientSocket, messageToClient, strlen(messageToClient), 0) < 0){
            puts("sending client data failed");
            return 1;
        }

        if(recv(clientSocket, clientResponse, 2000, 0) < 0){
            puts("received client data failed");
            return 1;
        }

        // teardown process when done with socket connection
        if(strcmp(messageToClient, command6) == 0)
        {
            close(clientSocket);
            close(serverSocket);
        }

        //puts("client response: ");
        //puts(clientResponse);
        break;

    }


    return 0;
}
